\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage{marginnote}
\usepackage{endnotes}

\usepackage{fancyhdr}

%Listings stuff
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{
basicstyle={\small\ttfamily},
tabsize=3,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{gray},
stepnumber=2,
breaklines=true
}

%Properly formatted differential 'd'
\newcommand{\ud}{\, \mathrm{d}}

%Format stuff
\pagestyle{fancy}
\headheight 35pt

%Header info
\chead{\Large \textbf{Quicksort}}
\lhead{}
\rhead{}

\begin{document}
\section{Algorithm}
	\marginnote{How much extra memory does quicksort require?}Quicksort is an \textbf{in-place} sorting algorithm with an average running time of $O(n\log n)$. It operates by successive partitions around a random pivot, which puts the pivot element in the correct, sorted position.
	
	\begin{lstlisting}[autogobble=true]
		Quicksort(A):
			if n==1: return
			p = random pivot index
			Partition(A)
			Quicksort(left)
			Quicksort(right)
	\end{lstlisting}
	
	\marginnote{What does partitioning do?}For partitioning, it is often best to assume that the pivot is the first element, which means that it will have to be pre-swapped in the main routine. A variable \verb|i| will mark the split between elements (first element larger than pivot).
	
	\marginnote{Runtime of parition?}
	\begin{lstlisting}[autogobble=true]
		Partition(A, l, r):	//l, r define subarray
			p = A[l]
			i = l+1
			for j in [l+1,...,r]:
				if A[j] < p:
					swap(A, i++, j)
			swap(A, l, i-1)	//Put the pivot in the proper place
	\end{lstlisting}
	
	\subsection{Duplicate Keys}
		Quicksort goes quadratic unless partitioning stops on equal keys (imagine a uniform array). This problem can be solved by 3-way partitioning, with the middle third with all of the keys equal to the pivot.
	
\section{Running Time}
	\marginnote{Best/worst way to choose pivot?}The main factor that determines the runtime of quicksort in practice is the way the pivot element is chosen.
	
	\begin{description}
		\item[Ideal:] choose the median every time: $O(n\log n)$
		\item[Worst:] choose the 1\textsuperscript{st} element in a sorted array: $O(n^2)$
		\marginnote{Average runtime of quicksort?}\item[Practical:] choose a random pivot. At worst a $25\%-75\%$ split after partition every iteration guarantees an $O(n\log n)$ running time.
	\end{description}
	
\section{Practical Improvements}
	\begin{itemize}
		\item Insertion sort cutoff around 10 elements.
		\item Estimate true median as partition by taking median of a size 3 sample (median-of-3 method) for medium arrays.
		\item Tukey's ninther for large arrays: pick 9 items, and take the median of the medians.
	\end{itemize}

	\endnotetext[1]{Quicksort is a randomized, in-place $O(n\log n)$ sort}
	\endnotetext[2]{The partition subroutine does all the work and puts the pivot in its sorted position}
	\def\enotesize{\normalsize}
	\theendnotes
\end{document}