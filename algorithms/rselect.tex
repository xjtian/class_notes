\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage{marginnote}
\usepackage{endnotes}

\usepackage{fancyhdr}

%Listings stuff
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{
basicstyle={\small\ttfamily},
tabsize=3,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{gray},
stepnumber=2,
breaklines=true
}

%Properly formatted differential 'd'
\newcommand{\ud}{\, \mathrm{d}}

%Format stuff
\pagestyle{fancy}
\headheight 35pt

%Header info
\chead{\Large \textbf{Randomized Selection}}
\lhead{}
\rhead{}

\begin{document}
\section{Problem}
	\begin{description}
		\item[Input:] \verb|A[...]| and an integer \verb|i|$\epsilon \{1,...,n\}$
		\item[Output:] i\textsuperscript{th} order statistic of \verb|A| (i\textsuperscript{th} smallest element)
	\end{description}
	
	\textbf{Reduction} to sorting: sort using any $O(n\log n)$ algorithm (preferably quicksort), and return \verb|A[i]|.
	
\section{Algorithm}
	\marginnote{What does RSelect piggyback off?}The algorithm for randomized selection is an adaptation of the partition subroutine used in quicksort.
	
	\begin{lstlisting}[autogobble=true]
		RSelect(A, i):
			if n==1: return A[0]
			p = rand(0, n)
			Partition(A, p)
			j = index_p	//After pivot has been moved
			
			if j==i: return pivot
			if j > i: return RSelect(left, i)
			if j < i: return RSelect(right, i-j)
	\end{lstlisting}
	
	\subsection{Deterministic Selection}
		Deterministic selection is not as efficient as RSelect in practice.
		\begin{lstlisting}[autogobble=true]
			DSelect(A, n, i):
				C = Choosepivot(A, n)
				p = DSelect(C, n/5, n/10)	//Recursively find median
				Partition(A, p)
				if j == i: return p
				if j < i: return DSelect(left, j-1, i)
				if j > i: return DSelect(right, n-j, i-j)
				
			ChoosePivot(A, n):
				Break A into groups of size 5 each
				Sort each group
				Copy n/5 medians into new array C
				return C
		\end{lstlisting}
	
\section{Running Time}
	\marginnote{What is the average runtime of RSelect?}The worst case running time is $O(n^2)$ when $p$ is the minimum every iteration, and the best case is $O(n)$ when $p$ is the median every iteration.
	
	\subsection{Analysis}
		\subsubsection{Proof 1: Tracking via Phases}
			\begin{itemize}
				\item RSelect is in phase $j$ if array size is between $\left(\dfrac{3}{4}^{j+1}\right)\cdot n$ and $\left(\dfrac{3}{4}^j\right)\cdot n$.
				\item $X_j = \text{number of recursive calls during phase j}$
				\item Runtime of RSelect, where $c$ is the constant multiplier of partition subroutine:
					\begin{equation}
						T\leq \sum_{phases j} X_j\cdot c \cdot\left(\frac{3}{4}\right)^j\cdot n
					\end{equation}
			\end{itemize}
			
		\subsubsection{Proof 2: Reduction to Coin-Flipping}
			\begin{itemize}
				\item If a pivot gives a 25-75 split or better, then phase j ends
				\item Therefore, there is a 50\% chance of choosing this phase-ending pivot
				\item $E[X_j]\leq\text{expected number of flips required to get one "heads"}$
			\end{itemize}
			
		\subsubsection{Proof 3: Coin Flipping Analysis}
			\begin{itemize}
				\item Let $N = \text{number of flips until heads}$, a geometric random variable.
				\begin{IEEEeqnarray}{rCl}
					E[N] & = & 1 + \frac{1}{2}E[N]\\
					E[N] & \leq & 2
				\end{IEEEeqnarray}
			\end{itemize}
			
		\subsubsection{Putting it Together}
			\begin{IEEEeqnarray}{rCl}
				T & \leq & \sum_j X_j\cdot c\cdot\left(\frac{3}{4}\right)^j\cdot n\\
				T & \leq & cn\sum_j\left(\frac{3}{4}\right)^j X_j\\
				E[T] & = & E\left[cn\sum_j\left(\frac{3}{4}\right)^j X_j\right]\\
				E[T] & = & cn\sum_j\left(\frac{3}{4}\right)^j\cdot E[X_j]\\
				E[X_j] & \leq & 2\\
				E[T] & \leq & 2cn\sum_j\left(\frac{3}{4}\right)^j\\
				E[T] & \leq & 8cn\\
				E[T] & = & O(n)
			\end{IEEEeqnarray}
	
	\endnotetext[1]{RSelect uses the partition subroutine}
	\endnotetext[2]{Clever math shows it averages $O(n)$, but can be as bad as $O(n^2)$}	
	\def\enotesize{\normalsize}
	\theendnotes
\end{document}