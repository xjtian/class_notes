\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage{fancyhdr}

%Listings stuff
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{
basicstyle={\small\ttfamily},
tabsize=3,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{gray},
stepnumber=2,
breaklines=true
}

%Format stuff
\pagestyle{fancy}
\headheight 35pt

%Header info
\chead{\Large \textbf{Selection}}
\lhead{}
\rhead{}

\begin{document}
\section{Problem}
	\begin{description}
		\item[Input:] \verb|A[...]| and an integer \verb|i|$\epsilon \{1,...,n\}$
		\item[Output:] i\textsuperscript{th} order statistic of \verb|A| (i\textsuperscript{th} smallest element)
	\end{description}
	
\section{Algorithm}
	The algorithm for randomized selection is an adaptation of the partition subroutine used in quicksort. The high-level idea is to partition a random element from the list, and if it ends up in the proper index, return it, or otherwise recurse on the appropriate half of the array.
	
	\begin{lstlisting}[autogobble=true]
		QuickSelect(A, i):
			if n==1: return A[0]
			p = rand(0, n)
			Partition(A, p)
			j = index_p	//After pivot has been moved
			
			if j==i: return pivot
			if j > i: return RSelect(left, i)
			if j < i: return RSelect(right, i-j)
	\end{lstlisting}
	
	
	
\section{Analysis}
	\subsection{Worst-Case Analysis}
		If we let the pivot element be random on every partition but assume that the element is never found until the end of the algorithm \textit{and} the algorithm always recurses on the larger half, we can get a reasonable upper bound for the average case of the algorithm. The recurrence is almost identical to the Quicksort recurrence (one less recursive call), so see the Quicksort notes for a more in-depth explanation.
		
		For the constructive induction, we guess $T(n) \leq an$.
		\begin{IEEEeqnarray}{rCl}
			T(n) & = & \frac{1}{n}\sum_{q=1}^n T(\verb|max(q-1, n-q)|) \quad + \quad n - 1\\
			& = & \frac{2}{n} \sum_{q=n/2}^{n-1} T(q) \quad + \quad n - 1\\
			& \leq & \frac{2}{n} \sum_{q=n/2}^{n-1} aq \quad + \quad n - 1\\
			& = & \frac{2a}{n}\left( \sum_{q=1}^{n-1} q - \sum_{q=1}^{\frac{n}{2} - 1} q \right) + n-1\\
			& = & \left(\frac{3a}{4} + 1\right)n - \frac{a}{2} - 1
		\end{IEEEeqnarray}
		
		For the constructive induction to hold,
		\begin{IEEEeqnarray}{rCl}
			\frac{3a}{4} + 1 & \leq & a\\
			a & \geq & 4
		\end{IEEEeqnarray}
		This pessimistic analysis yields $T(n) \leq 4n \in \Theta(n)$.
	
	\subsection{Probabilistic Analysis}
		Introduce the notation that the algorithm is in phase $j$ if the array size is between $\left(\dfrac{3}{4}\right)^{j+1}n$ and $\left(\dfrac{3}{4}\right)^jn$. If we call $X_j$ the expected number of recursive calls to finish phase $j$, then the runtime of the algorithm is
		\begin{equation}
			T \leq \sum_j X_j \left(\frac{3}{4}\right)^j n
		\end{equation}
		
		Now note that if a pivot gives a 25-75 split or better, then phase $j$ ends. There is a 50\% chance of choosing some arbitrary phase-ending pivot, so $E[X_j] = 2$. Now the formula for the runtime of the algorithm is
		\begin{IEEEeqnarray}{rCl}
			T & \leq & \sum_j X_j \left( \frac{3}{4} \right)^j n\\
			& = & 2n\sum_j \left( \frac{3}{4} \right)^j = 8n \in \Theta(n)
		\end{IEEEeqnarray}
			
\section{Deterministic Selection}
	Deterministic selection is not as efficient as QuickSelect in practice, and is much trickier to implement. It is still $\Theta(n)$, and is guaranteed to be so for all cases, but in practice has slower constants than QuickSelect.
	\begin{lstlisting}[autogobble=true]
		DSelect(A, n, i):
			C = Choosepivot(A, n)
			p = DSelect(C, n/5, n/10)	//Recursively find median
			Partition(A, p)
			if j == i: return p
			if j < i: return DSelect(left, j-1, i)
			if j > i: return DSelect(right, n-j, i-j)
			
		ChoosePivot(A, n):
			Break A into groups of size 5 each
			Sort each group
			Copy n/5 medians into new array C
			return C
	\end{lstlisting}
\end{document}