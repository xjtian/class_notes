\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage[pdftex]{graphicx}
\usepackage{tikz}
\usetikzlibrary{intersections}

\usepackage{marginnote}
\usepackage{endnotes}

\usepackage{fancyhdr}

%Listings stuff
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{
basicstyle={\small\ttfamily},
tabsize=3,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{gray},
stepnumber=2,
breaklines=true
}

%Properly formatted differential 'd'
\newcommand{\ud}{\, \mathrm{d}}

%Format stuff
\pagestyle{fancy}
\headheight 35pt

%Header info
\chead{\Large \textbf{Graph Search}}
\lhead{}
\rhead{}

\begin{document}
\section{Generic Search}
	\marginnote{Generic search?}\begin{lstlisting}[autogobble=true]
		def GenericSearch(G, start_vertex):
			mark all G unexplored, S explored
			while unexplored exist:
				choose edge (u, v) with u explored, v unexplored
				mark v explored
	\end{lstlisting}
	
	The difference in how the two most significant graph search algorithms, \textbf{breadth-first search} and \textbf{depth-first search} work is how each chooses the next node to explore.
	
	BFS explores nodes in "layers", exploring all of a vertex's neighbors before moving another level away. DFS explores aggressively, going as deep as possible before backtracking if necessary. BFS is often implemented with a queue (FIFO) structure, while DFS is implemented with a stack (FILO) or recursively. Both algorithms are $O(m+n)$.
	
\section{BFS}
	\marginnote{BFS structure?}\begin{lstlisting}[autogobble=true]
		def BFS(G, start):
			mark start explored
			enqueue(start)
			
			while !empty(queue):
				v = dequeue()
				mark v explored
				for (v, w) in G:
					if w unexplored:
						enqueue(w)
	\end{lstlisting}
	
	\marginnote{BFS runtime?}Runtime is actually $O(m_s + n_s)$, where $s$ means the edges and nodes reachable from the starting vertex.
	
	\subsection{Shortest Path Problem}
		\marginnote{Shortest path with BFS?}Given an undirected graph with equally-weighted edges, it is simple to adapt BFS to compute the shortest possible path between two vertices. Initialize all vertices with distance $\infty$ except the starting vertex with distance 0, and conduct BFS except if \verb|w| is unexplored, then \verb|dist(w) = dist(v) + 1|.
		
	\subsection{Undirected Connectivity}
		A connected component is an undirected subgraph where any two vertices are connected. They are the "pieces" of an undirected grpah, and there does not exist a path between two connected components. BFS can be adapted to find these subgraphs.
		\begin{lstlisting}[autogobble=true]
			def FindConnections(G):
				for V in G:
					if (V unexplored):
						BFS(G, V)	//Finds the connected vertices
		\end{lstlisting}
		
\section{DFS}
	\marginnote{Recursive DFS?}\begin{lstlisting}[autogobble=true]
		def DFS(G, start):
			start explored
			for (s, v) in G:
				if v unexplored:
					mark v explored
					DFS(G, v)
	\end{lstlisting}
	
	It is also possible to implement DFS with a stack if the recursive version busts the call stack.
	
	\subsection{Topological Sort}
		\marginnote{Topological order?}\textbf{Topological ordering} of a directed graph $G$ is a labeling function $f$ of $G$'s nodes such that
		\begin{equation}
			\forall (u,v)\in G, f(u) < f(v)
		\end{equation}
		\marginnote{DAG?}Note that this is only possible if there are no cycles present in $G$, as topological sorting turns $G$ into a \textbf{directed acyclic graph}, or DAG.
		
		\marginnote{DFS adaptation for top. order?}\begin{center}
		\begin{tabular}{ll}
			\begin{lstlisting}[autogobble=true]
				def DFS-Loop(G):
					label = n
					for v in G:
						if v unexplored:
							DFS_Top(G, v)
			\end{lstlisting} 
			& 
			\begin{lstlisting}[autogobble=true]
				def DFS_Top(G, v):
					v explored
					for (v, w) in G:
						if w unexplored:
							DFS_Topology(G, w)
					f(start) = label--
			\end{lstlisting}
		\end{tabular}
		\end{center}
		
		If we order the graph by increasing $f(v)$, then $G$ is clearly a DAG. This algorithm runs in $O(m+n)$ time if there are no cycles in $G$.
		
\section*{Important Concepts}
	\begin{itemize}
		\item BFS and DFS only differ basically in data structure used to pick next node.
		\item Both run in $O(m+n)$
		\item BFS can be used to compute shortest path, where distance is number of iterations it takes to reach target.
		\item Iterative BFS finds connected components of undirected graphs.
		\item DFS can compute the topological ordering of a directed graph.
	\end{itemize}

%	\begin{center}
%	\begin{tikzpicture}
%		[scale=3,line cap=round,
%		%Styles
%		axes/.style=,
%		important line/.style={very thick},
%		information text/.style={rounded corners,fill=red!10,inner sep=1ex},
%		dot/.style={circle,inner sep=1pt,fill,label={#1},name=#1}			
%		]
%		
%		%Colors
%		\colorlet{anglecolor}{green!50!black}	%angle arcs/lines
%		
%		%The graphic
%	\end{tikzpicture}
%	\end{center}

%	\begin{figure}[htb]
%		\centering
%		\includegraphics[width=0.8\textwidth]{filename.eps}
%		\caption{Caption.}
%		\label{fig:figure}
%	\end{figure}

%		\def\enotesize{\normalsize}
%		\theendnotes
\end{document}