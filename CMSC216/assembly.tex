\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage[pdftex]{graphicx}
\usepackage{tikz}
\usetikzlibrary{intersections}

\usepackage{marginnote}
\usepackage{endnotes}

\usepackage{fancyhdr}

%Listings stuff
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{
basicstyle={\small\ttfamily},
tabsize=3,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{gray},
stepnumber=2,
breaklines=true
}

%Properly formatted differential 'd'
\newcommand{\ud}{\, \mathrm{d}}

%Format stuff
\pagestyle{fancy}
\headheight 35pt

%Header info
\chead{\Large \textbf{Assembly}}
\lhead{}
\rhead{}

\begin{document}
\section{Assembler}
	An assembler takes assembly language and turns it into machine code, numeric
	instructions read into the processor. Modern processors break down machine
	code into ``micorcode'' even further.

	It is possible to disassemble machine code back into assembly, but any
	variable names and variables are lost.

	\subparagraph{Makefile} It is possible to write a makefile rule to use yas,
	the assembler, to compile a .ys assembly file to .yo.

	\begin{lstlisting}[autogobble=true]
		all: assembler.yo
			yis $<
		%.yo: %.ys
			yas $<
	\end{lstlisting}

	The machine used in 216 is ``y86'' as a simplified successor to the x86
	Intel processor.

\section{Instructions}
	\subsection{Operands}

		\subparagraph{Registers} Registers are very fast memory that hold a single
		word and  can be read or written in one cycle. In y86, e[abcd]x, e[sd]i and e[sb]p. The p's are
		pointers to the stack, the i's are indexes (source, destination), and the
		x's are general purpose, defined by convention.

		\subparagraph{Memory} take several cycles to fetch if not in cache, which is
		much faster.

		\subparagraph{Immediate} These are constants in the instruction itself, in
		the data segment. A pointer to a constant in the data segment would be an
		immediate.

	\subsection{Commands}
	
	\subparagraph{Movement} The \verb|movl| command moves data from one place to another. The first 2 characters specify the source and destination: \verb|i| means immediate, \verb|r| means register, and \verb|m| means memory.
	\begin{center}
	\begin{tabular}{l|l}
		Instruction	&	Effect\\\hline
		
		\verb|irmovl V, R|	& Reg[R]$\leftarrow$ V\\
		\verb|rrmovl rA, rB|	&	Reg[rB]$\leftarrow$ Reg[rA]\\
		\verb|rmmovl rA,D(rB)|	&	Mem[Reg[rB]+D] $\leftarrow$ Reg[rA]\\
		\verb|mrmovl D(rA),rB|	&	Reg[rB]$\leftarrow$Mem[Reg[rA] + D]\\
	\end{tabular}
	\end{center}
	
	\subparagraph{Integer Operations} There are 4 integer operations, \verb|addl|, \verb|subl|, \verb|andl|, and \verb|xorl| that only operation on register data. They set the three condition codes \verb|ZF|, \verb|SF|, and \verb|0F| (zero, sign, overflow) and are in the generic form \verb|OPl rA, rB|.
	
	\subparagraph{Jump} There are seven jump instructions: \verb|jmp|, \verb|jle|, \verb|jl|, \verb|je|, \verb|jne|, \verb|jge|, and \verb|jg|. The conditions are fairly self-explanatory, and the generic command is \verb|jXX Dest|.
	
	\subparagraph{Conditional Move}6 conditional move instructions: \verb|cmovle|, \verb|cmovl|, \verb|cmove|, \verb|cmovge|, and \verb|cmovg|. They are conditional forms of \verb|rrmovl| and are called like \verb|cmovXX rA, rB|.
	
	\subparagraph{Call and Return} the \verb|call| instruction pushes the return address on the stack and jumps to the destination: \verb|call Dest|. The \verb|ret| instruction returns from such a call.
	
	\subparagraph{Stack} \verb|pushl rA| and \verb|popl rA| manipulate the stack with register values. The stack holds $2^12$ bytes of memory and starts at the top by default, growing toward lower addresses towards global and static data. 
	
	\subparagraph{Miscellaneous} \verb|halt| stops instruction execution, setting the status code to \verb|HLT|. \verb|nop| is no operation, and the processor sleds through it.
	
	\subparagraph{Input/Output} \verb|rdch|, \verb|rdint|, \verb|wrch|, and \verb|wrint| are added commands to Y86 for input/output from standard input, and read/write an integer/character from/to standard input from/to the specified register.
	

%	\begin{center}
%	\begin{tikzpicture}
%		[scale=3,line cap=round,
%		%Styles
%		axes/.style=,
%		important line/.style={very thick},
%		information text/.style={rounded corners,fill=red!10,inner sep=1ex},
%		dot/.style={circle,inner sep=1pt,fill,label={#1},name=#1}			
%		]
%		
%		%Colors
%		\colorlet{anglecolor}{green!50!black}	%angle arcs/lines
%		
%		%The graphic
%	\end{tikzpicture}
%	\end{center}

%	\begin{figure}[htb]
%		\centering
%		\includegraphics[width=0.8\textwidth]{filename.eps}
%		\caption{Caption.}
%		\label{fig:figure}
%	\end{figure}

%		\def\enotesize{\normalsize}
%		\theendnotes
\end{document}
