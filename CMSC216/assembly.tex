\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage[pdftex]{graphicx}
\usepackage{tikz}
\usetikzlibrary{intersections}

\usepackage{marginnote}
\usepackage{endnotes}

\usepackage{fancyhdr}

%Listings stuff
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{
basicstyle={\small\ttfamily},
tabsize=3,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{gray},
stepnumber=2,
breaklines=true
}

%Properly formatted differential 'd'
\newcommand{\ud}{\, \mathrm{d}}

%Format stuff
\pagestyle{fancy}
\headheight 35pt

%Header info
\chead{\Large \textbf{Assembly}}
\lhead{}
\rhead{}

\begin{document}
\section{Assembler}
	An assembler takes assembly language and turns it into machine code, numeric
	instructions read into the processor. Modern processors break down machine
	code into ``micorcode'' even further.

	It is possible to disassemble machine code back into assembly, but any
	variable names and variables are lost.

	\subparagraph{Makefile} It is possible to write a makefile rule to use yas,
	the assembler, to compile a .ys assembly file to .yo.

	\begin{lstlisting}[autogobble=true]
		all: assembler.yo
			yis $<
		%.yo: %.ys
			yas $<
	\end{lstlisting}

	The machine used in 216 is ``y86'' as a simplified successor to the x86
	Intel processor.

\section{Instructions}
	\subsection{Operands}

		\subparagraph{Registers} Registers are very fast memory that hold a single
		word and  can be read or written in one cycle. In y86, e[abcd]x, e[sd]i and e[sb]p. The p's are
		pointers to the stack, the i's are indexes (source, destination), and the
		x's are general purpose, defined by convention.

		\subparagraph{Memory} take several cycles to fetch if not in cache, which is
		much faster.

		\subparagraph{Immediate} These are constants in the instruction itself, in
		the data segment. A pointer to a constant in the data segment would be an
		immediate.

	\subsection{Commands}
	
	\subparagraph{Movement} The \verb|movl| command moves data from one place to another. The first 2 characters specify the source and destination: \verb|i| means immediate, \verb|r| means register, and \verb|m| means memory.
	\begin{center}
	\begin{tabular}{l|l}
		Instruction	&	Effect\\\hline
		
		\verb|irmovl V, R|	& Reg[R]$\leftarrow$ V\\
		\verb|rrmovl rA, rB|	&	Reg[rB]$\leftarrow$ Reg[rA]\\
		\verb|rmmovl rA,D(rB)|	&	Mem[Reg[rB]+D] $\leftarrow$ Reg[rA]\\
		\verb|mrmovl D(rA),rB|	&	Reg[rB]$\leftarrow$Mem[Reg[rA] + D]\\
	\end{tabular}
	\end{center}
	
	\subparagraph{Integer Operations} There are 4 integer operations,
	\verb|addl|, \verb|subl|, \verb|andl|, and \verb|xorl| that only operation
	on register data. They set the three condition codes \verb|ZF|, \verb|SF|,
	and \verb|0F| (zero, sign, overflow) and are in the generic form \verb|OPl
	rA, rB|. The first register is the source register and the second is the
	destination, and the rule for applying the operation is ``dest <- dest op
	source''.
	
	\subparagraph{Jump} There are seven jump instructions: \verb|jmp|,
	\verb|jle|, \verb|jl|, \verb|je|, \verb|jne|, \verb|jge|, and \verb|jg|. The
	conditions are fairly self-explanatory (compares to 0), and the generic command is \verb|jXX Dest|.
	
	\subparagraph{Conditional Move}6 conditional move instructions: \verb|cmovle|, \verb|cmovl|, \verb|cmove|, \verb|cmovge|, and \verb|cmovg|. They are conditional forms of \verb|rrmovl| and are called like \verb|cmovXX rA, rB|.
	
	\subparagraph{Call and Return} the \verb|call| instruction pushes the return address on the stack and jumps to the destination: \verb|call Dest|. The \verb|ret| instruction returns from such a call.
	
	\subparagraph{Stack} \verb|pushl rA| and \verb|popl rA| manipulate the stack
	with register values. The stack holds $2^12$ bytes of memory and starts at
	the top by default, growing toward lower addresses towards global and static
	data. The stack begins at the location $0x1000$ and grows downwards, and the
	location of the `top' of the stack is kept in the stack pointer, the
	register designated by \verb|%esp|. When a register is pushed, \verb|%esp|
	is decremented by 4 and the old location it pointed to is overwritten with
	the register data. When the register is popped, the value on top of the
	stack is written to the register, and \verb|%esp| increments by 4. REMEMBER
	TO INITIALIZE WITH \verb|irmovl	$0x1000, %esp| BEFORE ANY STACK OPERATIONS.
	
	\subparagraph{Miscellaneous} \verb|halt| stops instruction execution, setting the status code to \verb|HLT|. \verb|nop| is no operation, and the processor sleds through it.
	
	\subparagraph{Input/Output} \verb|rdch|, \verb|rdint|, \verb|wrch|, and \verb|wrint| are added commands to Y86 for input/output from standard input, and read/write an integer/character from/to standard input from/to the specified register.
	

%	\begin{center}
%	\begin{tikzpicture}
%		[scale=3,line cap=round,
%		%Styles
%		axes/.style=,
%		important line/.style={very thick},
%		information text/.style={rounded corners,fill=red!10,inner sep=1ex},
%		dot/.style={circle,inner sep=1pt,fill,label={#1},name=#1}			
%		]
%		
%		%Colors
%		\colorlet{anglecolor}{green!50!black}	%angle arcs/lines
%		
%		%The graphic
%	\end{tikzpicture}
%	\end{center}

%	\begin{figure}[htb]
%		\centering
%		\includegraphics[width=0.8\textwidth]{filename.eps}
%		\caption{Caption.}
%		\label{fig:figure}
%	\end{figure}

%		\def\enotesize{\normalsize}
%		\theendnotes
\end{document}
